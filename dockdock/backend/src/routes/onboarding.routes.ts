import { Router } from 'express';
import * as onboardingController from '../controllers/onboarding.controller';
import * as reportController from '../controllers/report.controller';
import { authenticate } from '../middleware/auth.middleware';

const router = Router();

/**
 * @swagger
 * /api/v1/onboarding/genres:
 *   get:
 *     summary: Ïò®Î≥¥Îî© Ïû•Î•¥ Î™©Î°ù Ï°∞Ìöå
 *     tags: [Onboarding]
 *     description: |
 *       Ïò®Î≥¥Îî© Í≥ºÏ†ïÏóêÏÑú ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÌëúÏãúÌï† Ïû•Î•¥ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 *       Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌïòÏßÄ ÏïäÏäµÎãàÎã§.
 *
 *       ## üì± Swift ÏΩîÎìú ÏòàÏãú
 *
 *       ```swift
 *       // MARK: - OnboardingService.swift
 *
 *       struct GenreItem: Codable, Identifiable {
 *           let id: String
 *           let name: String
 *           let description: String?
 *           let icon: String?
 *       }
 *
 *       struct GenresResponse: Codable {
 *           let success: Bool
 *           let message: String
 *           let data: [GenreItem]
 *       }
 *
 *       func getOnboardingGenres() async throws -> [GenreItem] {
 *           return try await NetworkManager.shared.request(
 *               endpoint: .onboarding,
 *               path: "/genres",
 *               method: "GET",
 *               authenticated: false
 *           )
 *       }
 *
 *       // MARK: - SwiftUI ViewModel
 *
 *       @MainActor
 *       class GenreSelectionViewModel: ObservableObject {
 *           @Published var genres: [GenreItem] = []
 *           @Published var isLoading = false
 *           @Published var errorMessage: String?
 *
 *           func loadGenres() async {
 *               isLoading = true
 *               errorMessage = nil
 *
 *               do {
 *                   genres = try await OnboardingService.shared.getOnboardingGenres()
 *               } catch {
 *                   errorMessage = error.localizedDescription
 *               }
 *
 *               isLoading = false
 *           }
 *       }
 *
 *       // MARK: - SwiftUI View
 *
 *       struct GenreSelectionView: View {
 *           @StateObject private var viewModel = GenreSelectionViewModel()
 *
 *           var body: some View {
 *               Group {
 *                   if viewModel.isLoading {
 *                       ProgressView("Ïû•Î•¥ Î™©Î°ù Î°úÎî© Ï§ë...")
 *                   } else if let error = viewModel.errorMessage {
 *                       VStack {
 *                           Text("Ïò§Î•ò Î∞úÏÉù")
 *                               .font(.headline)
 *                           Text(error)
 *                               .font(.subheadline)
 *                               .foregroundColor(.secondary)
 *                           Button("Îã§Ïãú ÏãúÎèÑ") {
 *                               Task { await viewModel.loadGenres() }
 *                           }
 *                       }
 *                   } else {
 *                       ScrollView {
 *                           LazyVStack(spacing: 16) {
 *                               ForEach(viewModel.genres) { genre in
 *                                   GenreRow(genre: genre)
 *                               }
 *                           }
 *                           .padding()
 *                       }
 *                   }
 *               }
 *               .task {
 *                   await viewModel.loadGenres()
 *               }
 *           }
 *       }
 *
 *       struct GenreRow: View {
 *           let genre: GenreItem
 *
 *           var body: some View {
 *               HStack {
 *                   if let icon = genre.icon {
 *                       Text(icon)
 *                           .font(.title)
 *                   }
 *
 *                   VStack(alignment: .leading) {
 *                       Text(genre.name)
 *                           .font(.headline)
 *                       if let description = genre.description {
 *                           Text(description)
 *                               .font(.caption)
 *                               .foregroundColor(.secondary)
 *                       }
 *                   }
 *
 *                   Spacer()
 *               }
 *               .padding()
 *               .background(Color(.systemGray6))
 *               .cornerRadius(10)
 *           }
 *       }
 *       ```
 *     responses:
 *       200:
 *         description: Ïû•Î•¥ Î™©Î°ù Ï°∞Ìöå ÏÑ±Í≥µ
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.get('/genres', onboardingController.getOnboardingGenres);

/**
 * @swagger
 * /api/v1/onboarding/books/{genre}:
 *   get:
 *     summary: ÌäπÏ†ï Ïû•Î•¥Ïùò Ï±Ö Î™©Î°ù Ï°∞Ìöå
 *     tags: [Onboarding]
 *     description: |
 *       ÌäπÏ†ï Ïû•Î•¥Ïóê ÏÜçÌïòÎäî Ï∂îÏ≤ú Ï±Ö Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.
 *       Ïò®Î≥¥Îî© Í≥ºÏ†ïÏóêÏÑú ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†Ìò∏ÌïòÎäî Ï±ÖÏùÑ ÏÑ†ÌÉùÌï† Îïå ÏÇ¨Ïö©Ìï©ÎãàÎã§.
 *       Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌïòÏßÄ ÏïäÏäµÎãàÎã§.
 *
 *       ## üì± Swift ÏΩîÎìú ÏòàÏãú
 *
 *       ```swift
 *       // MARK: - OnboardingService.swift
 *
 *       struct OnboardingBook: Codable, Identifiable {
 *           let id: String
 *           let title: String
 *           let author: String?
 *           let cover_image_url: String?
 *           let publisher: String?
 *           let description: String?
 *           let category: String?
 *       }
 *
 *       struct GenreBooksResponse: Codable {
 *           let success: Bool
 *           let message: String
 *           let data: GenreBooksData
 *       }
 *
 *       struct GenreBooksData: Codable {
 *           let genre: String
 *           let books: [OnboardingBook]
 *           let total: Int
 *       }
 *
 *       func getGenreBooks(genre: String, limit: Int = 5) async throws -> [OnboardingBook] {
 *           var components = URLComponents(string: "\(APIConfig.baseAPIURL)/onboarding/books/\(genre)")
 *           components?.queryItems = [
 *               URLQueryItem(name: "limit", value: "\(limit)")
 *           ]
 *
 *           guard let url = components?.url else {
 *               throw APIError.invalidURL
 *           }
 *
 *           var request = URLRequest(url: url)
 *           request.httpMethod = "GET"
 *
 *           let (data, response) = try await URLSession.shared.data(for: request)
 *
 *           guard let httpResponse = response as? HTTPURLResponse,
 *                 (200...299).contains(httpResponse.statusCode) else {
 *               throw APIError.serverError("Failed to fetch books")
 *           }
 *
 *           let apiResponse = try JSONDecoder().decode(
 *               GenreBooksResponse.self,
 *               from: data
 *           )
 *
 *           return apiResponse.data.books
 *       }
 *
 *       // MARK: - SwiftUI ViewModel
 *
 *       @MainActor
 *       class GenreBooksViewModel: ObservableObject {
 *           @Published var books: [OnboardingBook] = []
 *           @Published var selectedBookIds: Set<String> = []
 *           @Published var isLoading = false
 *           @Published var errorMessage: String?
 *
 *           let genre: String
 *
 *           init(genre: String) {
 *               self.genre = genre
 *           }
 *
 *           func loadBooks() async {
 *               isLoading = true
 *               errorMessage = nil
 *
 *               do {
 *                   books = try await OnboardingService.shared.getGenreBooks(
 *                       genre: genre,
 *                       limit: 10
 *                   )
 *               } catch {
 *                   errorMessage = error.localizedDescription
 *               }
 *
 *               isLoading = false
 *           }
 *
 *           func toggleBookSelection(_ bookId: String) {
 *               if selectedBookIds.contains(bookId) {
 *                   selectedBookIds.remove(bookId)
 *               } else {
 *                   selectedBookIds.insert(bookId)
 *               }
 *           }
 *       }
 *
 *       // MARK: - SwiftUI View
 *
 *       struct GenreBooksView: View {
 *           @StateObject private var viewModel: GenreBooksViewModel
 *
 *           init(genre: String) {
 *               _viewModel = StateObject(wrappedValue: GenreBooksViewModel(genre: genre))
 *           }
 *
 *           var body: some View {
 *               VStack {
 *                   Text("\(viewModel.genre) Ï∂îÏ≤ú ÎèÑÏÑú")
 *                       .font(.title2)
 *                       .bold()
 *                       .padding(.top)
 *
 *                   if viewModel.isLoading {
 *                       ProgressView("Ï±Ö Î™©Î°ù Î°úÎî© Ï§ë...")
 *                           .padding()
 *                   } else if let error = viewModel.errorMessage {
 *                       VStack {
 *                           Text("Ïò§Î•ò Î∞úÏÉù")
 *                               .font(.headline)
 *                           Text(error)
 *                               .font(.subheadline)
 *                               .foregroundColor(.secondary)
 *                           Button("Îã§Ïãú ÏãúÎèÑ") {
 *                               Task { await viewModel.loadBooks() }
 *                           }
 *                       }
 *                   } else {
 *                       ScrollView {
 *                           LazyVStack(spacing: 16) {
 *                               ForEach(viewModel.books) { book in
 *                                   BookSelectionCard(
 *                                       book: book,
 *                                       isSelected: viewModel.selectedBookIds.contains(book.id)
 *                                   ) {
 *                                       viewModel.toggleBookSelection(book.id)
 *                                   }
 *                               }
 *                           }
 *                           .padding()
 *                       }
 *                   }
 *               }
 *               .task {
 *                   await viewModel.loadBooks()
 *               }
 *           }
 *       }
 *
 *       struct BookSelectionCard: View {
 *           let book: OnboardingBook
 *           let isSelected: Bool
 *           let action: () -> Void
 *
 *           var body: some View {
 *               Button(action: action) {
 *                   HStack(spacing: 12) {
 *                       // Ï±Ö Ïª§Î≤Ñ Ïù¥ÎØ∏ÏßÄ
 *                       AsyncImage(url: URL(string: book.cover_image_url ?? "")) { image in
 *                           image
 *                               .resizable()
 *                               .aspectRatio(contentMode: .fit)
 *                       } placeholder: {
 *                           Rectangle()
 *                               .fill(Color.gray.opacity(0.3))
 *                       }
 *                       .frame(width: 60, height: 90)
 *                       .cornerRadius(8)
 *
 *                       VStack(alignment: .leading, spacing: 4) {
 *                           Text(book.title)
 *                               .font(.headline)
 *                               .lineLimit(2)
 *                               .multilineTextAlignment(.leading)
 *
 *                           if let author = book.author {
 *                               Text(author)
 *                                   .font(.subheadline)
 *                                   .foregroundColor(.secondary)
 *                           }
 *
 *                           if let publisher = book.publisher {
 *                               Text(publisher)
 *                                   .font(.caption)
 *                                   .foregroundColor(.secondary)
 *                           }
 *                       }
 *
 *                       Spacer()
 *
 *                       // ÏÑ†ÌÉù Ï≤¥ÌÅ¨ÎßàÌÅ¨
 *                       Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
 *                           .foregroundColor(isSelected ? .blue : .gray)
 *                           .font(.title2)
 *                   }
 *                   .padding()
 *                   .background(isSelected ? Color.blue.opacity(0.1) : Color(.systemGray6))
 *                   .cornerRadius(12)
 *                   .overlay(
 *                       RoundedRectangle(cornerRadius: 12)
 *                           .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
 *                   )
 *               }
 *               .buttonStyle(PlainButtonStyle())
 *           }
 *       }
 *       ```
 *     tags: [Onboarding]
 *     parameters:
 *       - in: path
 *         name: genre
 *         required: true
 *         schema:
 *           type: string
 *         description: Ïû•Î•¥ Ïù¥Î¶Ñ
 *         example: "ÏÜåÏÑ§"
 *       - in: query
 *         name: limit
 *         schema:
 *           type: number
 *           default: 5
 *         description: Î∞òÌôòÌï† ÏµúÎåÄ Ï±Ö Ïàò
 *     responses:
 *       200:
 *         description: Ïû•Î•¥Î≥Ñ Ï±Ö Î™©Î°ù Ï°∞Ìöå ÏÑ±Í≥µ
 *       400:
 *         description: ÏûòÎ™ªÎêú ÏöîÏ≤≠
 *       404:
 *         description: Ïû•Î•¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.get('/books/:genre', onboardingController.getGenreBooks);

/**
 * @swagger
 * /api/v1/onboarding/preferences:
 *   post:
 *     summary: ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ Ï†ÄÏû•
 *     tags: [Onboarding]
 *     description: |
 *       ÏÇ¨Ïö©ÏûêÍ∞Ä Ïò®Î≥¥Îî© Í≥ºÏ†ïÏóêÏÑú ÏÑ†ÌÉùÌïú ÏÑ†Ìò∏ Ïû•Î•¥ÏôÄ Ï±ÖÏùÑ Ï†ÄÏû•Ìï©ÎãàÎã§
 *
 *       ## üì± Swift ÏΩîÎìú ÏòàÏãú
 *
 *       ```swift
 *       // MARK: - OnboardingService.swift
 *
 *       struct SavePreferencesRequest: Encodable {
 *           let preferred_genres: [String]
 *           let selected_book_ids: [String]?
 *       }
 *
 *       struct PreferencesResponse: Codable {
 *           let success: Bool
 *           let message: String
 *           let data: UserPreferences?
 *       }
 *
 *       struct UserPreferences: Codable {
 *           let id: String
 *           let user_id: String
 *           let preferred_genres: [String]
 *           let onboarding_completed: Bool
 *           let created_at: String
 *           let updated_at: String
 *       }
 *
 *       func savePreferences(genres: [String], bookIds: [String]? = nil) async throws -> PreferencesResponse {
 *           let request = SavePreferencesRequest(
 *               preferred_genres: genres,
 *               selected_book_ids: bookIds
 *           )
 *
 *           return try await NetworkManager.shared.request(
 *               endpoint: .onboarding,
 *               path: "/preferences",
 *               method: "POST",
 *               body: request,
 *               authenticated: true
 *           )
 *       }
 *
 *       // MARK: - SwiftUI ViewModel
 *
 *       @MainActor
 *       class OnboardingViewModel: ObservableObject {
 *           @Published var selectedGenres: Set<String> = []
 *           @Published var selectedBooks: Set<String> = []
 *           @Published var isLoading = false
 *           @Published var errorMessage: String?
 *           @Published var onboardingCompleted = false
 *
 *           let availableGenres = [
 *               "ÏÜåÏÑ§", "Ïãú/ÏóêÏÑ∏Ïù¥", "ÏûêÍ∏∞Í≥ÑÎ∞ú", "Í≤ΩÏ†ú/Í≤ΩÏòÅ",
 *               "Ïù∏Î¨∏", "Ïó≠ÏÇ¨", "Í≥ºÌïô", "ÏòàÏà†", "Ï¢ÖÍµê", "Ïó¨Ìñâ"
 *           ]
 *
 *           func savePreferences() async {
 *               guard !selectedGenres.isEmpty else {
 *                   errorMessage = "ÏµúÏÜå 1Í∞ú Ïù¥ÏÉÅÏùò Ïû•Î•¥Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî"
 *                   return
 *               }
 *
 *               isLoading = true
 *               errorMessage = nil
 *
 *               do {
 *                   let genresArray = Array(selectedGenres)
 *                   let booksArray = selectedBooks.isEmpty ? nil : Array(selectedBooks)
 *
 *                   _ = try await OnboardingService.shared.savePreferences(
 *                       genres: genresArray,
 *                       bookIds: booksArray
 *                   )
 *
 *                   onboardingCompleted = true
 *               } catch {
 *                   errorMessage = error.localizedDescription
 *               }
 *
 *               isLoading = false
 *           }
 *       }
 *
 *       // MARK: - SwiftUI View
 *
 *       struct OnboardingGenreSelectionView: View {
 *           @StateObject private var viewModel = OnboardingViewModel()
 *           @Environment(\.dismiss) private var dismiss
 *
 *           let columns = [
 *               GridItem(.flexible()),
 *               GridItem(.flexible())
 *           ]
 *
 *           var body: some View {
 *               NavigationView {
 *                   VStack(spacing: 20) {
 *                       // Ìó§Îçî
 *                       VStack(spacing: 8) {
 *                           Text("Ïñ¥Îñ§ Ïû•Î•¥Î•º Ï¢ãÏïÑÌïòÏãúÎÇòÏöî?")
 *                               .font(.title2)
 *                               .bold()
 *
 *                           Text("Í¥ÄÏã¨ÏûàÎäî Ïû•Î•¥Î•º Î™®Îëê ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî")
 *                               .font(.subheadline)
 *                               .foregroundColor(.secondary)
 *                       }
 *                       .padding(.top)
 *
 *                       // Ïû•Î•¥ ÏÑ†ÌÉù
 *                       ScrollView {
 *                           LazyVGrid(columns: columns, spacing: 12) {
 *                               ForEach(viewModel.availableGenres, id: \.self) { genre in
 *                                   GenreButton(
 *                                       genre: genre,
 *                                       isSelected: viewModel.selectedGenres.contains(genre)
 *                                   ) {
 *                                       if viewModel.selectedGenres.contains(genre) {
 *                                           viewModel.selectedGenres.remove(genre)
 *                                       } else {
 *                                           viewModel.selectedGenres.insert(genre)
 *                                       }
 *                                   }
 *                               }
 *                           }
 *                           .padding()
 *                       }
 *
 *                       if let error = viewModel.errorMessage {
 *                           Text(error)
 *                               .foregroundColor(.red)
 *                               .font(.caption)
 *                               .padding(.horizontal)
 *                       }
 *
 *                       // Îã§Ïùå Î≤ÑÌäº
 *                       Button {
 *                           Task {
 *                               await viewModel.savePreferences()
 *                           }
 *                       } label: {
 *                           HStack {
 *                               if viewModel.isLoading {
 *                                   ProgressView()
 *                                       .tint(.white)
 *                               } else {
 *                                   Text("Îã§Ïùå (\(viewModel.selectedGenres.count)/\(viewModel.availableGenres.count))")
 *                               }
 *                           }
 *                           .frame(maxWidth: .infinity)
 *                           .padding()
 *                           .background(viewModel.selectedGenres.isEmpty ? Color.gray : Color.blue)
 *                           .foregroundColor(.white)
 *                           .cornerRadius(12)
 *                       }
 *                       .disabled(viewModel.selectedGenres.isEmpty || viewModel.isLoading)
 *                       .padding(.horizontal)
 *                       .padding(.bottom)
 *                   }
 *                   .navigationBarTitleDisplayMode(.inline)
 *                   .onChange(of: viewModel.onboardingCompleted) { _, completed in
 *                       if completed {
 *                           dismiss()
 *                       }
 *                   }
 *               }
 *           }
 *       }
 *
 *       struct GenreButton: View {
 *           let genre: String
 *           let isSelected: Bool
 *           let action: () -> Void
 *
 *           var body: some View {
 *               Button(action: action) {
 *                   Text(genre)
 *                       .font(.body)
 *                       .padding(.vertical, 12)
 *                       .padding(.horizontal, 20)
 *                       .frame(maxWidth: .infinity)
 *                       .background(isSelected ? Color.blue : Color(.systemGray6))
 *                       .foregroundColor(isSelected ? .white : .primary)
 *                       .cornerRadius(10)
 *                       .overlay(
 *                           RoundedRectangle(cornerRadius: 10)
 *                               .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
 *                       )
 *               }
 *           }
 *       }
 *       ```
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - preferred_genres
 *             properties:
 *               preferred_genres:
 *                 type: array
 *                 items:
 *                   type: string
 *                 description: ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌïú ÏÑ†Ìò∏ Ïû•Î•¥ Î™©Î°ù
 *                 example: ["ÏÜåÏÑ§", "Ïãú/ÏóêÏÑ∏Ïù¥", "ÏûêÍ∏∞Í≥ÑÎ∞ú"]
 *               selected_book_ids:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: uuid
 *                 description: ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌïú Ï±Ö ID Î™©Î°ù (ÏÑ†ÌÉùÏÇ¨Ìï≠)
 *     responses:
 *       200:
 *         description: ÏÑ†Ìò∏ÎèÑ Ï†ÄÏû• ÏÑ±Í≥µ
 *       400:
 *         description: ÏûòÎ™ªÎêú ÏöîÏ≤≠
 *       401:
 *         description: Ïù∏Ï¶ù Ïã§Ìå®
 */
router.post('/preferences', authenticate, onboardingController.saveUserPreferences);

/**
 * @swagger
 * /api/v1/onboarding/status:
 *   get:
 *     summary: Ïò®Î≥¥Îî© ÏÉÅÌÉú ÌôïÏù∏
 *     tags: [Onboarding]
 *     description: |
 *       ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÏùò Ïò®Î≥¥Îî© ÏôÑÎ£å Ïó¨Î∂ÄÎ•º ÌôïÏù∏Ìï©ÎãàÎã§.
 *       Ïï± ÏãúÏûë Ïãú Ïò®Î≥¥Îî© ÌôîÎ©¥ ÌëúÏãú Ïó¨Î∂ÄÎ•º Í≤∞Ï†ïÌï† Îïå ÏÇ¨Ïö©Ìï©ÎãàÎã§.
 *
 *       ## üì± Swift ÏΩîÎìú ÏòàÏãú
 *
 *       ```swift
 *       // MARK: - OnboardingService.swift
 *
 *       struct OnboardingStatusResponse: Codable {
 *           let success: Bool
 *           let message: String
 *           let data: OnboardingStatus
 *       }
 *
 *       struct OnboardingStatus: Codable {
 *           let onboarding_completed: Bool
 *           let preferred_genres: [String]?
 *           let completed_at: String?
 *       }
 *
 *       func getOnboardingStatus() async throws -> OnboardingStatus {
 *           return try await NetworkManager.shared.request(
 *               endpoint: .onboarding,
 *               path: "/status",
 *               method: "GET",
 *               authenticated: true
 *           )
 *       }
 *
 *       // MARK: - SwiftUI ViewModel
 *
 *       @MainActor
 *       class AppViewModel: ObservableObject {
 *           @Published var showOnboarding = false
 *           @Published var isCheckingOnboarding = true
 *
 *           func checkOnboardingStatus() async {
 *               isCheckingOnboarding = true
 *
 *               do {
 *                   let status = try await OnboardingService.shared.getOnboardingStatus()
 *                   showOnboarding = !status.onboarding_completed
 *               } catch {
 *                   // Ïò®Î≥¥Îî© ÏÉÅÌÉú Ï°∞Ìöå Ïã§Ìå® Ïãú Ïò®Î≥¥Îî© ÌëúÏãú
 *                   showOnboarding = true
 *                   print("Failed to check onboarding status: \(error)")
 *               }
 *
 *               isCheckingOnboarding = false
 *           }
 *       }
 *
 *       // MARK: - SwiftUI View
 *
 *       @main
 *       struct DockDockApp: App {
 *           @StateObject private var appViewModel = AppViewModel()
 *
 *           var body: some Scene {
 *               WindowGroup {
 *                   Group {
 *                       if appViewModel.isCheckingOnboarding {
 *                           // Ïä§ÌîåÎûòÏãú ÌôîÎ©¥
 *                           SplashView()
 *                       } else if appViewModel.showOnboarding {
 *                           // Ïò®Î≥¥Îî© ÌôîÎ©¥
 *                           OnboardingFlowView()
 *                       } else {
 *                           // Î©îÏù∏ ÌôîÎ©¥
 *                           MainTabView()
 *                       }
 *                   }
 *                   .task {
 *                       await appViewModel.checkOnboardingStatus()
 *                   }
 *               }
 *           }
 *       }
 *
 *       struct SplashView: View {
 *           var body: some View {
 *               VStack {
 *                   Image("AppLogo")
 *                       .resizable()
 *                       .scaledToFit()
 *                       .frame(width: 120, height: 120)
 *
 *                   ProgressView()
 *                       .padding(.top, 20)
 *               }
 *           }
 *       }
 *       ```
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Ïò®Î≥¥Îî© ÏÉÅÌÉú Ï°∞Ìöå ÏÑ±Í≥µ
 *       401:
 *         description: Ïù∏Ï¶ù Ïã§Ìå®
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.get('/status', authenticate, onboardingController.getOnboardingStatus);

/**
 * @swagger
 * /api/v1/onboarding/report/generate:
 *   post:
 *     summary: Ïò®Î≥¥Îî© Î†àÌè¨Ìä∏ ÏÉùÏÑ±
 *     tags: [Onboarding]
 *     description: |
 *       ÏÇ¨Ïö©ÏûêÏùò Ïò®Î≥¥Îî© Îç∞Ïù¥ÌÑ∞Î•º Í∏∞Î∞òÏúºÎ°ú Í∞úÏù∏ÌôîÎêú ÎèÖÏÑú ÏÑ±Ìñ• Î†àÌè¨Ìä∏Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
 *       OpenAI GPTÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏÇ¨Ïö©ÏûêÏùò ÎèÖÏÑú Ï∑®Ìñ•ÏùÑ Î∂ÑÏÑùÌïòÍ≥† Ï∂îÏ≤úÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
 *
 *       ## üì± Swift ÏΩîÎìú ÏòàÏãú
 *
 *       ```swift
 *       // MARK: - OnboardingService.swift
 *
 *       struct GenerateReportRequest: Encodable {
 *           let onboardingData: OnboardingData
 *       }
 *
 *       struct OnboardingData: Codable {
 *           let preferred_genres: [String]
 *           let selected_books: [SelectedBook]?
 *           let reading_frequency: String?
 *           let reading_goals: [String]?
 *       }
 *
 *       struct SelectedBook: Codable {
 *           let id: String
 *           let title: String
 *           let author: String?
 *       }
 *
 *       struct ReportResponse: Codable {
 *           let success: Bool
 *           let message: String
 *           let data: ReadingReport
 *       }
 *
 *       struct ReadingReport: Codable, Identifiable {
 *           let id: String
 *           let user_id: String
 *           let reading_personality: String
 *           let genre_analysis: String
 *           let book_recommendations: [BookRecommendation]
 *           let reading_tips: [String]
 *           let created_at: String
 *       }
 *
 *       struct BookRecommendation: Codable, Identifiable {
 *           let id: String
 *           let title: String
 *           let author: String
 *           let reason: String
 *       }
 *
 *       func generateReport(onboardingData: OnboardingData) async throws -> ReadingReport {
 *           let request = GenerateReportRequest(onboardingData: onboardingData)
 *
 *           return try await NetworkManager.shared.request(
 *               endpoint: .onboarding,
 *               path: "/report/generate",
 *               method: "POST",
 *               body: request,
 *               authenticated: true
 *           )
 *       }
 *
 *       // MARK: - SwiftUI ViewModel
 *
 *       @MainActor
 *       class ReportGenerationViewModel: ObservableObject {
 *           @Published var report: ReadingReport?
 *           @Published var isGenerating = false
 *           @Published var errorMessage: String?
 *           @Published var progress: Double = 0.0
 *
 *           func generateReport(
 *               genres: [String],
 *               selectedBooks: [SelectedBook]?,
 *               readingFrequency: String?,
 *               readingGoals: [String]?
 *           ) async {
 *               isGenerating = true
 *               errorMessage = nil
 *               progress = 0.0
 *
 *               let onboardingData = OnboardingData(
 *                   preferred_genres: genres,
 *                   selected_books: selectedBooks,
 *                   reading_frequency: readingFrequency,
 *                   reading_goals: readingGoals
 *               )
 *
 *               // ÏßÑÌñâÎ•† Ïï†ÎãàÎ©îÏù¥ÏÖò
 *               Task {
 *                   while isGenerating && progress < 0.9 {
 *                       try? await Task.sleep(nanoseconds: 500_000_000) // 0.5Ï¥à
 *                       progress += 0.1
 *                   }
 *               }
 *
 *               do {
 *                   report = try await OnboardingService.shared.generateReport(
 *                       onboardingData: onboardingData
 *                   )
 *                   progress = 1.0
 *               } catch {
 *                   errorMessage = error.localizedDescription
 *               }
 *
 *               isGenerating = false
 *           }
 *       }
 *
 *       // MARK: - SwiftUI View
 *
 *       struct ReportGenerationView: View {
 *           @StateObject private var viewModel = ReportGenerationViewModel()
 *           let genres: [String]
 *           let selectedBooks: [SelectedBook]?
 *
 *           var body: some View {
 *               VStack(spacing: 20) {
 *                   if viewModel.isGenerating {
 *                       VStack(spacing: 16) {
 *                           Text("üìö ÎèÖÏÑú ÏÑ±Ìñ• Î∂ÑÏÑù Ï§ë...")
 *                               .font(.title3)
 *                               .bold()
 *
 *                           ProgressView(value: viewModel.progress)
 *                               .progressViewStyle(LinearProgressViewStyle())
 *                               .padding(.horizontal, 40)
 *
 *                           Text("\(Int(viewModel.progress * 100))%")
 *                               .font(.caption)
 *                               .foregroundColor(.secondary)
 *
 *                           Text("ÎãπÏã†ÎßåÏùò ÎèÖÏÑú Î†àÌè¨Ìä∏Î•º ÏûëÏÑ±ÌïòÍ≥† ÏûàÏñ¥Ïöî")
 *                               .font(.subheadline)
 *                               .foregroundColor(.secondary)
 *                               .multilineTextAlignment(.center)
 *                       }
 *                       .padding()
 *                   } else if let report = viewModel.report {
 *                       ReportDetailView(report: report)
 *                   } else if let error = viewModel.errorMessage {
 *                       VStack {
 *                           Text("Î†àÌè¨Ìä∏ ÏÉùÏÑ± Ïã§Ìå®")
 *                               .font(.headline)
 *                           Text(error)
 *                               .font(.subheadline)
 *                               .foregroundColor(.secondary)
 *                           Button("Îã§Ïãú ÏãúÎèÑ") {
 *                               Task {
 *                                   await viewModel.generateReport(
 *                                       genres: genres,
 *                                       selectedBooks: selectedBooks,
 *                                       readingFrequency: nil,
 *                                       readingGoals: nil
 *                                   )
 *                               }
 *                           }
 *                       }
 *                   }
 *               }
 *               .task {
 *                   await viewModel.generateReport(
 *                       genres: genres,
 *                       selectedBooks: selectedBooks,
 *                       readingFrequency: nil,
 *                       readingGoals: nil
 *                   )
 *               }
 *           }
 *       }
 *       ```
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - onboardingData
 *             properties:
 *               onboardingData:
 *                 type: object
 *                 properties:
 *                   preferred_genres:
 *                     type: array
 *                     items:
 *                       type: string
 *                   selected_books:
 *                     type: array
 *                     items:
 *                       type: object
 *                   reading_frequency:
 *                     type: string
 *                   reading_goals:
 *                     type: array
 *                     items:
 *                       type: string
 *     responses:
 *       200:
 *         description: Î†àÌè¨Ìä∏ ÏÉùÏÑ± ÏÑ±Í≥µ
 *       400:
 *         description: ÏûòÎ™ªÎêú ÏöîÏ≤≠
 *       401:
 *         description: Ïù∏Ï¶ù Ïã§Ìå®
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.post('/report/generate', authenticate, reportController.generateReport);

/**
 * @swagger
 * /api/v1/onboarding/report:
 *   get:
 *     summary: ÏÇ¨Ïö©Ïûê ÎèÖÏÑú Î†àÌè¨Ìä∏ Ï°∞Ìöå
 *     tags: [Onboarding]
 *     description: |
 *       ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÏùò ÎèÖÏÑú ÏÑ±Ìñ• Î†àÌè¨Ìä∏Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 *       Ïù¥ÎØ∏ ÏÉùÏÑ±Îêú Î†àÌè¨Ìä∏Í∞Ä ÏûàÎäî Í≤ΩÏö∞ Ìï¥Îãπ Î†àÌè¨Ìä∏Î•º Î∞òÌôòÌï©ÎãàÎã§.
 *
 *       ## üì± Swift ÏΩîÎìú ÏòàÏãú
 *
 *       ```swift
 *       // MARK: - OnboardingService.swift
 *
 *       func getUserReport() async throws -> ReadingReport {
 *           return try await NetworkManager.shared.request(
 *               endpoint: .onboarding,
 *               path: "/report",
 *               method: "GET",
 *               authenticated: true
 *           )
 *       }
 *
 *       // MARK: - SwiftUI ViewModel
 *
 *       @MainActor
 *       class UserReportViewModel: ObservableObject {
 *           @Published var report: ReadingReport?
 *           @Published var isLoading = false
 *           @Published var errorMessage: String?
 *
 *           func loadReport() async {
 *               isLoading = true
 *               errorMessage = nil
 *
 *               do {
 *                   report = try await OnboardingService.shared.getUserReport()
 *               } catch {
 *                   errorMessage = error.localizedDescription
 *               }
 *
 *               isLoading = false
 *           }
 *       }
 *
 *       // MARK: - SwiftUI View
 *
 *       struct ReportDetailView: View {
 *           let report: ReadingReport
 *
 *           var body: some View {
 *               ScrollView {
 *                   VStack(alignment: .leading, spacing: 24) {
 *                       // Ìó§Îçî
 *                       VStack(alignment: .leading, spacing: 8) {
 *                           Text("üìö ÎÇòÏùò ÎèÖÏÑú ÏÑ±Ìñ•")
 *                               .font(.title)
 *                               .bold()
 *
 *                           Text("ÏÉùÏÑ±Ïùº: \(formatDate(report.created_at))")
 *                               .font(.caption)
 *                               .foregroundColor(.secondary)
 *                       }
 *
 *                       Divider()
 *
 *                       // ÎèÖÏÑú ÏÑ±Ìñ•
 *                       VStack(alignment: .leading, spacing: 12) {
 *                           Label("ÎèÖÏÑú ÏÑ±Ìñ•", systemImage: "person.fill")
 *                               .font(.headline)
 *
 *                           Text(report.reading_personality)
 *                               .font(.body)
 *                               .foregroundColor(.secondary)
 *                       }
 *                       .padding()
 *                       .background(Color(.systemGray6))
 *                       .cornerRadius(12)
 *
 *                       // Ïû•Î•¥ Î∂ÑÏÑù
 *                       VStack(alignment: .leading, spacing: 12) {
 *                           Label("Ïû•Î•¥ Î∂ÑÏÑù", systemImage: "chart.bar.fill")
 *                               .font(.headline)
 *
 *                           Text(report.genre_analysis)
 *                               .font(.body)
 *                               .foregroundColor(.secondary)
 *                       }
 *                       .padding()
 *                       .background(Color(.systemGray6))
 *                       .cornerRadius(12)
 *
 *                       // Ï∂îÏ≤ú ÎèÑÏÑú
 *                       VStack(alignment: .leading, spacing: 12) {
 *                           Label("Ï∂îÏ≤ú ÎèÑÏÑú", systemImage: "book.fill")
 *                               .font(.headline)
 *
 *                           ForEach(report.book_recommendations) { recommendation in
 *                               VStack(alignment: .leading, spacing: 8) {
 *                                   HStack {
 *                                       Text(recommendation.title)
 *                                           .font(.subheadline)
 *                                           .bold()
 *                                       Spacer()
 *                                   }
 *
 *                                   Text(recommendation.author)
 *                                       .font(.caption)
 *                                       .foregroundColor(.secondary)
 *
 *                                   Text(recommendation.reason)
 *                                       .font(.caption)
 *                                       .foregroundColor(.secondary)
 *                                       .padding(.top, 4)
 *                               }
 *                               .padding()
 *                               .background(Color(.systemBackground))
 *                               .cornerRadius(8)
 *                           }
 *                       }
 *                       .padding()
 *                       .background(Color(.systemGray6))
 *                       .cornerRadius(12)
 *
 *                       // ÎèÖÏÑú ÌåÅ
 *                       VStack(alignment: .leading, spacing: 12) {
 *                           Label("ÎèÖÏÑú ÌåÅ", systemImage: "lightbulb.fill")
 *                               .font(.headline)
 *
 *                           ForEach(Array(report.reading_tips.enumerated()), id: \.offset) { index, tip in
 *                               HStack(alignment: .top, spacing: 8) {
 *                                   Text("\(index + 1).")
 *                                       .font(.subheadline)
 *                                       .bold()
 *
 *                                   Text(tip)
 *                                       .font(.subheadline)
 *                                       .foregroundColor(.secondary)
 *                               }
 *                           }
 *                       }
 *                       .padding()
 *                       .background(Color(.systemGray6))
 *                       .cornerRadius(12)
 *                   }
 *                   .padding()
 *               }
 *               .navigationTitle("ÎèÖÏÑú Î†àÌè¨Ìä∏")
 *               .navigationBarTitleDisplayMode(.inline)
 *           }
 *
 *           private func formatDate(_ dateString: String) -> String {
 *               let formatter = ISO8601DateFormatter()
 *               guard let date = formatter.date(from: dateString) else {
 *                   return dateString
 *               }
 *
 *               let displayFormatter = DateFormatter()
 *               displayFormatter.dateFormat = "yyyyÎÖÑ MMÏõî ddÏùº"
 *               return displayFormatter.string(from: date)
 *           }
 *       }
 *
 *       // ÏÇ¨Ïö© ÏòàÏãú
 *       struct MyReportView: View {
 *           @StateObject private var viewModel = UserReportViewModel()
 *
 *           var body: some View {
 *               Group {
 *                   if viewModel.isLoading {
 *                       ProgressView("Î†àÌè¨Ìä∏ Î∂àÎü¨Ïò§Îäî Ï§ë...")
 *                   } else if let report = viewModel.report {
 *                       ReportDetailView(report: report)
 *                   } else if let error = viewModel.errorMessage {
 *                       VStack {
 *                           Text("Î†àÌè¨Ìä∏Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§")
 *                               .font(.headline)
 *                           Text(error)
 *                               .font(.subheadline)
 *                               .foregroundColor(.secondary)
 *                           Button("Îã§Ïãú ÏãúÎèÑ") {
 *                               Task { await viewModel.loadReport() }
 *                           }
 *                       }
 *                   }
 *               }
 *               .task {
 *                   await viewModel.loadReport()
 *               }
 *           }
 *       }
 *       ```
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Î†àÌè¨Ìä∏ Ï°∞Ìöå ÏÑ±Í≥µ
 *       404:
 *         description: Î†àÌè¨Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå
 *       401:
 *         description: Ïù∏Ï¶ù Ïã§Ìå®
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.get('/report', authenticate, reportController.getUserReport);

/**
 * @swagger
 * /api/v1/onboarding/report/regenerate:
 *   post:
 *     summary: ÎèÖÏÑú Î†àÌè¨Ìä∏ Ïû¨ÏÉùÏÑ±
 *     tags: [Onboarding]
 *     description: |
 *       Í∏∞Ï°¥ Î†àÌè¨Ìä∏Î•º ÏÇ≠Ï†úÌïòÍ≥† ÏÉàÎ°úÏö¥ Ïò®Î≥¥Îî© Îç∞Ïù¥ÌÑ∞Î°ú Î†àÌè¨Ìä∏Î•º Ïû¨ÏÉùÏÑ±Ìï©ÎãàÎã§.
 *       ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†Ìò∏ Ïû•Î•¥ÎÇò Ï±ÖÏùÑ Î≥ÄÍ≤ΩÌñàÏùÑ Îïå ÏÇ¨Ïö©Ìï©ÎãàÎã§.
 *
 *       ## üì± Swift ÏΩîÎìú ÏòàÏãú
 *
 *       ```swift
 *       // MARK: - OnboardingService.swift
 *
 *       struct RegenerateReportRequest: Encodable {
 *           let onboardingData: OnboardingData
 *       }
 *
 *       func regenerateReport(onboardingData: OnboardingData) async throws -> ReadingReport {
 *           let request = RegenerateReportRequest(onboardingData: onboardingData)
 *
 *           return try await NetworkManager.shared.request(
 *               endpoint: .onboarding,
 *               path: "/report/regenerate",
 *               method: "POST",
 *               body: request,
 *               authenticated: true
 *           )
 *       }
 *
 *       // MARK: - SwiftUI ViewModel
 *
 *       @MainActor
 *       class ReportRegenerationViewModel: ObservableObject {
 *           @Published var report: ReadingReport?
 *           @Published var isRegenerating = false
 *           @Published var errorMessage: String?
 *           @Published var showConfirmation = false
 *
 *           func regenerateReport(
 *               genres: [String],
 *               selectedBooks: [SelectedBook]?,
 *               readingFrequency: String?,
 *               readingGoals: [String]?
 *           ) async {
 *               isRegenerating = true
 *               errorMessage = nil
 *
 *               let onboardingData = OnboardingData(
 *                   preferred_genres: genres,
 *                   selected_books: selectedBooks,
 *                   reading_frequency: readingFrequency,
 *                   reading_goals: readingGoals
 *               )
 *
 *               do {
 *                   report = try await OnboardingService.shared.regenerateReport(
 *                       onboardingData: onboardingData
 *                   )
 *               } catch {
 *                   errorMessage = error.localizedDescription
 *               }
 *
 *               isRegenerating = false
 *           }
 *       }
 *
 *       // MARK: - SwiftUI View
 *
 *       struct ReportSettingsView: View {
 *           @StateObject private var viewModel = ReportRegenerationViewModel()
 *           @State private var selectedGenres: Set<String> = []
 *
 *           let availableGenres = [
 *               "ÏÜåÏÑ§", "Ïãú/ÏóêÏÑ∏Ïù¥", "ÏûêÍ∏∞Í≥ÑÎ∞ú", "Í≤ΩÏ†ú/Í≤ΩÏòÅ",
 *               "Ïù∏Î¨∏", "Ïó≠ÏÇ¨", "Í≥ºÌïô", "ÏòàÏà†", "Ï¢ÖÍµê", "Ïó¨Ìñâ"
 *           ]
 *
 *           var body: some View {
 *               NavigationView {
 *                   Form {
 *                       Section(header: Text("ÏÑ†Ìò∏ Ïû•Î•¥ ÏàòÏ†ï")) {
 *                           ForEach(availableGenres, id: \.self) { genre in
 *                               HStack {
 *                                   Text(genre)
 *                                   Spacer()
 *                                   if selectedGenres.contains(genre) {
 *                                       Image(systemName: "checkmark")
 *                                           .foregroundColor(.blue)
 *                                   }
 *                               }
 *                               .contentShape(Rectangle())
 *                               .onTapGesture {
 *                                   if selectedGenres.contains(genre) {
 *                                       selectedGenres.remove(genre)
 *                                   } else {
 *                                       selectedGenres.insert(genre)
 *                                   }
 *                               }
 *                           }
 *                       }
 *
 *                       Section {
 *                           Button(action: {
 *                               viewModel.showConfirmation = true
 *                           }) {
 *                               HStack {
 *                                   Spacer()
 *                                   if viewModel.isRegenerating {
 *                                       ProgressView()
 *                                   } else {
 *                                       Text("Î†àÌè¨Ìä∏ Ïû¨ÏÉùÏÑ±")
 *                                           .bold()
 *                                   }
 *                                   Spacer()
 *                               }
 *                           }
 *                           .disabled(selectedGenres.isEmpty || viewModel.isRegenerating)
 *                       }
 *
 *                       if let error = viewModel.errorMessage {
 *                           Section {
 *                               Text(error)
 *                                   .foregroundColor(.red)
 *                                   .font(.caption)
 *                           }
 *                       }
 *                   }
 *                   .navigationTitle("Î†àÌè¨Ìä∏ ÏÑ§Ï†ï")
 *                   .alert("Î†àÌè¨Ìä∏ Ïû¨ÏÉùÏÑ±", isPresented: $viewModel.showConfirmation) {
 *                       Button("Ï∑®ÏÜå", role: .cancel) { }
 *                       Button("Ïû¨ÏÉùÏÑ±", role: .destructive) {
 *                           Task {
 *                               await viewModel.regenerateReport(
 *                                   genres: Array(selectedGenres),
 *                                   selectedBooks: nil,
 *                                   readingFrequency: nil,
 *                                   readingGoals: nil
 *                               )
 *                           }
 *                       }
 *                   } message: {
 *                       Text("Í∏∞Ï°¥ Î†àÌè¨Ìä∏Í∞Ä ÏÇ≠Ï†úÎêòÍ≥† ÏÉàÎ°úÏö¥ Î†àÌè¨Ìä∏Í∞Ä ÏÉùÏÑ±Îê©ÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?")
 *                   }
 *                   .sheet(item: $viewModel.report) { report in
 *                       NavigationView {
 *                           ReportDetailView(report: report)
 *                               .navigationTitle("ÏÉà Î†àÌè¨Ìä∏")
 *                               .navigationBarTitleDisplayMode(.inline)
 *                               .toolbar {
 *                                   ToolbarItem(placement: .navigationBarTrailing) {
 *                                       Button("ÏôÑÎ£å") {
 *                                           viewModel.report = nil
 *                                       }
 *                                   }
 *                               }
 *                       }
 *                   }
 *               }
 *           }
 *       }
 *
 *       // Î†àÌè¨Ìä∏ ÏÉÅÏÑ∏ ÌôîÎ©¥ÏóêÏÑú Ïû¨ÏÉùÏÑ± Î≤ÑÌäº Ï∂îÍ∞Ä
 *       struct ReportDetailWithRegenerateView: View {
 *           let report: ReadingReport
 *           @State private var showSettings = false
 *
 *           var body: some View {
 *               ReportDetailView(report: report)
 *                   .toolbar {
 *                       ToolbarItem(placement: .navigationBarTrailing) {
 *                           Button {
 *                               showSettings = true
 *                           } label: {
 *                               Image(systemName: "arrow.clockwise")
 *                           }
 *                       }
 *                   }
 *                   .sheet(isPresented: $showSettings) {
 *                       ReportSettingsView()
 *                   }
 *           }
 *       }
 *       ```
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - onboardingData
 *             properties:
 *               onboardingData:
 *                 type: object
 *                 properties:
 *                   preferred_genres:
 *                     type: array
 *                     items:
 *                       type: string
 *                   selected_books:
 *                     type: array
 *                     items:
 *                       type: object
 *                   reading_frequency:
 *                     type: string
 *                   reading_goals:
 *                     type: array
 *                     items:
 *                       type: string
 *     responses:
 *       200:
 *         description: Î†àÌè¨Ìä∏ Ïû¨ÏÉùÏÑ± ÏÑ±Í≥µ
 *       400:
 *         description: ÏûòÎ™ªÎêú ÏöîÏ≤≠
 *       401:
 *         description: Ïù∏Ï¶ù Ïã§Ìå®
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.post('/report/regenerate', authenticate, reportController.regenerateReport);

export default router;
